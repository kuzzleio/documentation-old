---
layout: full.html
algolia: true
title: Working with Persistent Data
order: 400
---

# Working with Persistent Data

Kuzzle Backend relies on [Elasticsearch](https://www.elastic.co/) to store and fetch persistent data.

In Kuzzle Backend, data is organized as follows:

* **Documents** are atomic units of data that are each defined in JSON format and contain a unique `_id`.
* **Collections** are a group of Documents, identified by a unique name.
* **Indexes** are a group of Collections, identified by a unique name.

---

## Why document identifiers are not part of their content?

Contrary to relational databases, where primary and foreign keys are stored in data tables and used to identify parts and subparts of data, NoSQL databases are key-value repositories.

As Kuzzle has been primarily built to work with document-oriented databases (a subset of NoSQL databases), each stored value is a whole document, meaning that key-value pairs are more like id-document pairs.

This means that document identifiers are not a part of the content they are referencing, but external values used to identify document contents.

This is why Kuzzle API handles `_id` and `_source` arguments separately, as the rest of this guide below will show.

---

## Creating a new index

Before continuing this tutorial, we need to [**create a new index**]({{ site_base_path }}api-documentation/controller-index/create/) where we will store collections.

To create a new index, we need only send the following `POST` request to the API endpoint (you can leave the body empty): `http://localhost:7512/<index name>/_create`

Let's create an index named `myindex`:

```bash
 curl -X POST http://localhost:7512/myindex/_create
```

You should receive the following response:

```json
{
    "requestId": "<random unique request id>",
    "status": 200,
    "error": null,
    "controller": "index",
    "action": "create",
    "collection": null,
    "index": "myindex",
    "volatile": null,
    "result": {
        "acknowledged": true,
        "shards_acknowledged": true
    }
}
```

## Creating a new collection

Next, we will [**create a new collection**]({{ site_base_path }}api-documentation/controller-collection/create/) in the `myindex` index, that will store our documents.

To do so, we need to send the following `PUT` request: `http://localhost:7512/myindex/<colletion name>`

Let's create the collection `mycollection`:

```bash
 curl -X PUT http://localhost:7512/myindex/mycollection
```

You should receive the following response:

```json
{
    "requestId": "<random unique request id>",
    "status": 200,
    "error": null,
    "controller": "collection",
    "action": "create",
    "collection": "mycollection",
    "index": "myindex",
    "volatile": null,
    "result": {
        "acknowledged": true
    }
}
```

**Note:** we have just created a new collection without any field mappings. The database layer will automatically create a mapping for new fields, by trying to infer the datatype from to the input data. Since a mapping cannot be changed once it is created, we strongly recommend that you [**update the collection mappings**]({{ site_base_path }}guide/essentials/persisted/#document-mapping) as soon as the collection has been created. For the purpose of this tutorial, we will continue this tutorial with autogenerated field mappings.

--- 

## Getting a list of existing collections

To browse the [**list of collections**]({{ site_base_path }}api-documentation/controller-collection/list) in a given index you can send a `GET` request to `http://localhost:7512/<index name>/_list`. 

Let's get the list of collections created under the `myindex` index:

```bash
 curl http://localhost:7512/myindex/_list
```

You should receive the following response:

```json
{
  "status": 200,
  "error": null,
  "requestId": "<random unique request id>",
  "controller": "collection",
  "action": "list",
  "collection": null,
  "index": "myindex",
  "volatile": null,
  "headers": {},
  "result": {
    "collections": [
      {
        "name": "mycollection",
        "type": "stored"
      }
    ],
    "type": "all"
  }
}
```

The `result` field in the response contains an array of `collections`, each defined by a `name` and a `type`.  
Note that the `mycollection` type is `stored` which means it is a persistant store. This allows us to distinguish between persistant store collections and volatile collections that are used as channels for [real-time messages]({{ site_base_path }}guide/essentials/real-time).

---

## Document CRUD

Kuzzle Backend ships with a full data [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) API that can be used to manage documents.

** CREATE **

We can [**create a new document**]({{ site_base_path }}api-documentation/controller-document/create) by sending a `POST` request to the API endpoint `http://localhost:7512/<index name>/<collection name>/_create` and setting the document contents in the request body.

Let's create a new document in the `mycollection` collection of the `myindex` index: 

```bash
 curl -X POST -H "Content-Type: application/json" -d '{"message": "Hello, world!"}' http://192.168.56.101:7512/myindex/mycollection/_create
```

You should receive the following response:

```json
{
  "status": 200,
  "error": null,
  "requestId": "<random unique request id>",
  "controller": "document",
  "action": "create",
  "collection": "mycollection",
  "index": "myindex",
  "volatile": null,
  "headers": {},
  "result": {
    "_index": "myindex",
    "_type": "mycollection",
    "_id": "AVkDBl3YsT6qHI7MxLz0",
    "_version": 1,
    "result": "created",
    "_shards": {
      "total": 2,
      "successful": 1,
      "failed": 0
    },
    "created": true,
    "_source": {
      "message": "Hello, world!"
    },
    "_meta": {
      "author": "-1",
      "createdAt": 1481814465050,
      "updatedAt": null,
      "updater": null,
      "active": true,
      "deletedAt": null
    }
  }
}
```

Note that the document contains the auto-generated id `AVkDBl3YsT6qHI7MxLz0`. Take some time to examine the content of the [response]({{ site_base_path }}guide/essentials/request-and-response-format/#status-codes) as it contains useful information, like the name of the controller and the action performed in the request, and of course the document we just created.

** UPDATE **

We can [**update a document**]({{ site_base_path }}api-documentation/controller-document/update) by sending a `PUT` request to `http://localhost:7512/<index name>/<collection name>/<document id>/_update` and setting the document's updated contents in the request body.

Let's [**modify to our brand new document**]({{ site_base_path }}api-documentation/controller-document/update) by sending a `PUT` request to `http://localhost:7512/myindex/mycollection/AVkDBl3YsT6qHI7MxLz0/_update` with the body set to:

Let's update the document we just created, with id `AVkDBl3YsT6qHI7MxLz0`, in the `mycollection` collection of the `myindex` index: 


```bash
 curl -X PUT -H "Content-Type: application/json" -d '{"message": "in a bottle","an_englishman":"in New York"}' http://192.168.56.101:7512/myindex/mycollection/AVkDBl3YsT6qHI7MxLz0/_update
```

You should receive the following response:

```json
{
  "status": 200,
  "error": null,
  "requestId": "6241ec4d-8529-43ba-9b77-3028b99cd621",
  "controller": "document",
  "action": "update",
  "collection": "mycollection",
  "index": "myindex",
  "volatile": null,
  "headers": {},
  "result": {
    "_index": "myindex",
    "_type": "mycollection",
    "_id": "AVkDBl3YsT6qHI7MxLz0",
    "_version": 2,
    "result": "updated",
    "_shards": {
      "total": 2,
      "successful": 1,
      "failed": 0
    }
  }
}
```

** DELETE **


Now, we'll let you figure out what happens when we send a `DELETE` request to `http://localhost:7512/myindex/mycollection/AVkDBl3YsT6qHI7MxLz0` with an empty body (take a look at the [API Reference]({{ site_base_path }}api-documentation/controller-document/delete) if you don't want to try).

---

## Document Search

One thing that Elasticsearch is _really_ good at doing is... Searching! It enables to create extremely precise search queries, thanks to its powerful query DSL. We wrote a [comprehensive cookbook]({{ site_base_path }}elasticsearch-cookbook) to help you understand how it works in detail, but let's take a look at a couple of simple examples, just to get started.

Say we want to [**find**]({{ site_base_path }}api-documentation/controller-document/search) all the documents within `mycollection`, via the HTTP protocol. To do it, we send a `POST` request to `http://localhost:7512/myindex/mycollection/_search` (we leave the body empty since we have no filters to apply to our query). Depending on the documents you have created in your database, the response will look like:

```json
{
  "status": 200,
  "error": null,
  "requestId": "<random unique request id>",
  "controller": "document",
  "action": "search",
  "collection": "mycollection",
  "index": "myindex",
  "volatile": null,
  "headers": {},
  "result": {
    "took": 69,
    "timed_out": false,
    "_shards": {
      "total": 5,
      "successful": 5,
      "failed": 0
    },
    "hits": [
      {
        "_index": "myindex",
        "_type": "mycollection",
        "_id": "AVkDLAdCsT6qHI7MxLz4",
        "_score": 0,
        "_source": {
          "message": "Hey! Ho!"
        },
        "_meta": {
          "author": "-1",
          "createdAt": 1481816934209,
          "updatedAt": null,
          "updater": null,
          "active": true,
          "deletedAt": null
        }
      },
      {
        "_index": "myindex",
        "_type": "mycollection",
        "_id": "AVkDK9iNsT6qHI7MxLz3",
        "_score": 0,
        "_source": {
          "message": "Hello, world!"
        },
        "_meta": {
          "author": "-1",
          "createdAt": 1481816922252,
          "updatedAt": null,
          "updater": null,
          "active": true,
          "deletedAt": null
        }
      },
      {
        "_index": "myindex",
        "_type": "mycollection",
        "_id": "AVkDLCdRsT6qHI7MxLz5",
        "_score": 0,
        "_source": {
          "message": "Let's go!"
        },
        "_meta": {
          "author": "-1",
          "createdAt": 1481816942415,
          "updatedAt": null,
          "updater": null,
          "active": true,
          "deletedAt": null
        }
      }
    ],
    "total": 3,
    "max_score": 0
  }
}
```

Looks neat. Say that now we only want to **query** the documents containing the word `Hey` in the `message` field. We can achieve this by adding the following query to our body:

```json
{
  "query": {
      "match": {
          "message":"Hey"
      }
    }
}
```

Which gives, as a result, the following response:

```json
{
  "status": 200,
  "error": null,
  "requestId": "<random unique request id>",
  "controller": "document",
  "action": "search",
  "collection": "mycollection",
  "index": "myindex",
  "volatile": null,
  "headers": {},
  "result": {
    "took": 6,
    "timed_out": false,
    "_shards": {
      "total": 5,
      "successful": 5,
      "failed": 0
    },
    "hits": [
      {
        "_index": "myindex",
        "_type": "mycollection",
        "_id": "AVkDLAdCsT6qHI7MxLz4",
        "_score": 0.25811607,
        "_source": {
          "message": "Hey! Ho!"
        },
        "_meta": {
          "author": "-1",
          "createdAt": 1481816934209,
          "updatedAt": null,
          "updater": null,
          "active": true,
          "deletedAt": null
        }
      }
    ],
    "total": 1,
    "max_score": 0.25811607
  }
}
```

---

## Document mapping

As previously said, Kuzzle relies on Elasticsearch to persist documents. Elasticsearch uses a mapping internally to match a document field to a field type. This mapping is attached to a `collection` (a `type` in Elasticsearch terminology).
If no mapping is defined, Elasticsearch will infer it automatically from input documents.

ou may want to define mappings manually, especially to provide more details to Elasticsearch on how it should interpret the documents stored in your collections.
To do so, Kuzzle expose a mapping creation API route.
This is done by sending a `PUT` request to the API endpoint `http://localhost:7512/myindex/mycollection/_mapping` with the body set to your mapping:

```json
{
  "properties": {
    "someField": {
      "type": "date"
    }
  }
}
```

Which gives us the following response:

```json
{
  "action": "updateMapping",
  "collection": "mycollection",
  "controller": "collection",
  "error": null,
  "index": "myindex",
  "volatile": null,
  "requestId": "<random unique request id>",
  "result": {
    "acknowledged": true
  },
  "status": 200
}
```

Here we defined a new field called `someField` of type `date` in our collection `mycollection`. This is especially useful when
dealing with capabilities such as specific types (`date`, `geo_shape`, ...), full-text search and complex data structures (`nested`, ...) of Elasticsearch.
As the mapping of the collection can not be changed once it is set (even if Elasticsearch did it automatically for you),
you should almost always define mappings when creating collections, preferably before sending documents in them.

The syntax to use is the one defined by [Elasticsearch](https://www.elastic.co/guide/en/elasticsearch/reference/5.x/mapping.html).

---

## Where do we go from here?


* Refer to the [Elasticsearch cookbook]({{ site_base_path }}elasticsearch-cookbook) to get more details on how querying works in Kuzzle
* Get history information, put a document in the trashcan and recover it, using [document metadata]({{ site_base_path }}guide/essentials/document-metadata)
* Keep track of the changes on your documents via the [Real-time Notifications]({{ site_base_path }}guide/essentials/real-time)
